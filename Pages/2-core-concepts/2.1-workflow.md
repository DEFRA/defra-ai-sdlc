# 2.1 - Workflow

Think of this workflow as your roadmap for building software with AI as your coding partner. It's not about replacing everything you already know – it's about adding AI tools to the development process you're already familiar with.

Most of this follows the same best practices recognised best practices already established throughout government.

![](attachments/development-workflow-diagram.png)

*Image: Simplified development workflow diagram*

## How AI Fits Into Your Existing Process

Here's how each step works in practice, with real examples of what you'll actually be doing:

### 1. Start With Your Product Idea

This is the same user research and service design work you've always done. Nothing changes here – you still need to understand the problem you're solving and who you're solving it for.

**What this looks like:** "We need a way for users to check their application status online instead of calling our office."

### 2. Generate Requirements With AI

Here's where AI starts helping. Instead of spending days writing detailed requirements documents, you can have a conversation with ChatGPT or Claude to flesh out the details.

**Example prompt:** "I need to build a status checker for government applications. Help me create detailed requirements including user stories, data models, and technical specifications."

**What you'll get:** Comprehensive requirements that would normally take hours to write, ready in minutes. You'll still review and refine them, but the heavy lifting is done.

### 3. Create Your Feature Branch

Same git workflow you've always used. Create a new branch, keep your changes isolated, and prepare for code review later.

**Nothing new here** – just your standard `git checkout -b feature/JIRA-123-status-checker` workflow.

### 4. Generate Code From Requirements

Now the magic happens. Take those requirements and paste them into your AI IDE (like Cursor) along with a specific prompt about what you want to build.

**Example:** "Using the requirements above, create a React component that displays application status with a search function and loading states."

**What's different:** Instead of writing boilerplate from scratch, you get a solid foundation to build on. You'll still need to review and refine – but you're getting a big helping start instead of a blank file.

### 5. Generate Tests Alongside Code

Generate your tests from the same requirements, separately from your code. This ensures your tests actually verify the business logic, not just the implementation.

**Why this works:** When tests are generated independently of code, they catch more bugs and ensure you're building what was actually requested.

**Example prompt:** "Create unit tests for the status checker requirements that verify all the user stories are working correctly."

### 6. Refactor and Polish

Use AI to clean up the generated code. Ask it to improve performance, follow your team's coding standards, or add error handling.

**Common refactoring prompts:**
- "Make this code more readable and add error handling"
- "Optimize this for better performance"
- "Ensure this follows our TypeScript conventions"

**Meta:** Consider turning refactor prompts into Rules so the AI can use them again in the future.

### 7. Update Documentation

AI makes writing documentation painless. Generate or update your docs based on the changes you've made.

**Example:** "Update the API documentation to reflect these new endpoints and response formats."

### 8. Create MR and Review as Normal

This step stays exactly the same. Create your merge request and have a colleague review every line. AI-generated code still needs human oversight – in fact, it's more important than ever to verify the code does what you intended.

**What to look for:** Does the code actually solve the original problem? Is it maintainable? Does it follow your security guidelines?

### 9. Deploy With Confidence

Your existing deployment pipeline handles everything from here. No changes needed to your CI/CD process.

## Why This Workflow Works

This approach gives you the best of both worlds:

**Speed without chaos:** You get code faster, but it still goes through proper review and testing.

**Quality control:** Every piece of AI-generated code gets human verification before it reaches production.

**Familiar process:** Your team doesn't need to learn an entirely new way of working – just new tools within the existing workflow.

**Reduced busywork:** AI handles the repetitive stuff (boilerplate, documentation, basic tests) while you focus on the interesting problems.

Remember: you're not trying to revolutionise everything at once. Start small, build confidence, and gradually integrate AI where it adds the most value.

## [Next -> 2.2 - The 4 Pillars](2.2-four-pillars.md)